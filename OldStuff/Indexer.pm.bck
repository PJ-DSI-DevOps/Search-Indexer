package Text::Indexer;

use strict;
use warnings;
use Carp;
use Fcntl;
use DB_File;

our $VERSION = "1.00";

=head1 NAME

Text::Indexer - Simple indexer for text data

=head1 SYNOPSIS



=head1 DESCRIPTION



=cut




sub new {
  my $class = shift;
  my $args = shift;

  my $self = {name => $args->{name} or croak "no name for new index",
	      dir => $args->{dir} or croak "no dir for new index",
	      ix => undef,
	      wregex => $args->{wregex}  || qr/\w+/,
	      wfilter => $args->{wregex} || sub {
		my $word = lc(shift);
		$word =~ tr[çáàâäéèêëíìîïóòôöúùûüýÿ] 
		           [caaaaeeeeiiiioooouuuuyy];
		return $word;
	      }
	     };

  bless $self, $class;
  return $self;
}



sub prepare_add {
  tie %{$self->{ix}}, 'DB_File', 
    "$self->{dir}/$self->{name}", O_CREAT|O_RDWR or
      croak "open $self->{dir}/$self->{name} for writing: $!"
	unless $self->{ix};

  # BUGGY WAY to lock, see man DB_FILE
  my $fd = tied(%{$self->{ix}})->fd;
  open(DB_FH, "+<&=$fd") or croak "dup $!";
  flock (DB_FH, LOCK_EX) or croak "flock: $!";

  tie %{$self->{ixp}}, 'DB_File', 
    "$self->{dir}/$self->{name}p", O_CREAT|O_RDWR or
      croak "open $self->{dir}/$self->{name}p for writing: $!"
	unless $self->{ixp};

}


sub finish_add {
  my $fd = tied(%{$self->{ix}})->fd;
  open(DB_FH, "+<&=$fd") or croak "dup $!";
  flock (DB_FH, LOCK_UN) or croak "flock: $!";
}





=item C<add(docId, buf)>

Add a new document to the index.
I<docId> is the unique identifier for this doc.
I<buf> is a scalar containing the text representation of this doc.

=cut

sub add {
  my $self = shift;
  my $docId = shift;
  # my $buf = shift; # using $_[0] instead for efficiency reasons

  my %positions;
  for (my $nwords = 1; $_[0] =~ /$self->{wregex}/g; $nwords++) {	
    my $word = &{$self->{wfilter}}($&) or next;	
    $positions{$word} = [] unless exists $positions{$word};
    push @{$positions{$word}}, $nwords;
  }

  foreach my $word (keys %positions) { 
    my $occurrences = @{$positions{$word}};
    $occurrences = 255 if $occurrences > 255;
    $self->{ix}{$word} .= pack('SC', $docId, $occurrences);
    $self->{ixp}{pack('SA*', $docId, $word)} = pack('S*', @{$positions{$word}});
  }
}


# Query structure :
[0 => [mandatory ]
 1 => [elim]
 2 => [others]
]

sub search {
  my $self = shift;
  my $query = shift;

  my $scores;

  if (ref $query) { # compound query

    my ($firstplus, @otherplus) = @{$query->[0]};
    if ($firstplus) {
      $scores = $self->search($firstplus);
      foreach my $subquery (@otherplus) {
	my $newScores =  $self->search($subquery);
	foreach my $k (keys %$scores) {
	  if (defined $newScores->{$k}) { $scores->{$k} += $newScores->{$k}; }
	  else                          { delete $scores->{$k}; }
	}
      }
    }

    my $final = $scores || {};

    foreach my $subquery (@{$query->[1]}) {
      my $newScores = $self->search($subquery);
      foreach my $k (keys %$newScores) {
	$final->{$k} += $newScores->{$k} unless 
	  $scores and not defined $scores->{$k};
      }
    }


    foreach my $subquery (@{$query->[2]}) {
      my $items = $self->search($subquery);
      map {delete $final->{$_}} keys %$items;
      last if not keys $%final;
    }

    return $final;
  }
  else { # single term query
    my %items = unpack '(SC)*', $self->{ix}{$query->[1]};
    
    my @k = keys %items;
    my $c = log(($ndocs + 1)/@k) * 100;

    map {$items{$_} = int($c * $items{$_}) } @k;
    return \%items;
  }




  if ($query->[0] eq Q_TERM) {
  } 
  elsif ($query->[0] eq Q_PHRASE) {
    

  } 
  elsif ($query->[0] eq Q_AND) {
    my $scores = self->search($query->[1]);
    for (my $i =2; $i < @$query; $i++) {
      my $s = self->search($query->[$i]);
      foreach my $k (keys %$scores) {
	if (defined $s->{$k}) {
	  $scores->{$k} += $s->{$k}; 
	}
	else {
	  delete $scores->{$k};
	} 
      }
    } 
  }
  elsif ($query->[0] eq Q_OR) {
    
    my $scores = self->search($query->[1]);
    for (my $i =2; $i < @$query; $i++) {
      my $s = self->search($query->[$i]);
      foreach my $k (keys %$scores) {
	if (defined $s->{$k}) {
	  $scores->{$k} += $s->{$k}; 
	}
	else {
	  delete $scores->{$k};
	} 
      }
    } 


  } 
  elsif ($query->[0] eq Q_NOT) {
    

  } 
}



sub parseQuery {
  my $query = shift;

  sub parser {
    $query =~ s/^\s+//;
    for ($query) {
      s/^"\s*([^"]+?)\s*"// and do { my $s = $1; return [$s =~ /$term/g ] }
      s/^\(//               and do { my $r = parser(); 
				     s/^\s*\)// and return $r;
				     croak "unmatched ( in query" }
      s/^\+//               and return {'+' => parser(); };
      s/^-//                and return {'-' => parser(); };
      s/^$term//            and return $&;
      length($_)            and croak "unexpected string in query : $_";
      return undef;
    }
  }

  while (my $tok = parser()) {
    for (ref $tok) {
      /ARRAY/ and do {push @{$q{''}}, $tok; next }
      /HASH/ and  do {my ($k, $v) = %$tok; 
		      push @{$q{$k}}, $v;
		      next }
      push @{$q{''}}, $tok;
    }
  }

}





sub parseQuery {
  my %q = ('+' => [], '-' => [], '' => []);

  my $e = '';
  my $le = '';

  while (1) {

    for ($_[0]) {
      s/^\s+//;
      last unless length($_);

      s/^(\+|-)//           and do { $e = $1; next };

      s/^"\s*([^"]+?)\s*"// and do { my $s = $1;
				     push @{$q{$e}}, [$s =~ /$term/g ];
				     $le = $e; $e = '';
				     next }

      s/^\(//               and do { my $r = parseQuery(); 
				     s/^\s*\)//  or croak "unmatched ( ";
				     push @{$q{$e}}, $r;
				     $le = $e; $e = '';
				     next }

      s/^$term//            and do { push @{$q{$e}}, $&; 
				     $le = $e; $e = '';
				     next }

      s/^AND|ET//           and do { croak " AND after '$le'" if $le;
				     push @{$q{'+'}}, pop @{$q{''}}; 
				     $e = '+';
				     next }

      s/^OR|OU//            and do { croak " OR after '$le'" if $le;
				     next }


      croak "unexpected string in query : $_";
    }
  }

  return \%q;
}


Query
 Term t
 Phrase @t
 And @q
 Or @q
 Not $q
